// Generated by CoffeeScript 1.4.0
/*
Copyright (c) 2012 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

/*
Jasmine test suite for Deft.promise.Promise
*/

describe('Deft.promise.Promise', function() {
  var generateCombinations, generatePermutations, wasSpyCalled, wasSpyCalledWith;
  generatePermutations = function(array) {
    var swap, _generatePermutations;
    swap = function(array, indexA, indexB) {
      var tmp;
      tmp = array[indexA];
      array[indexA] = array[indexB];
      array[indexB] = tmp;
    };
    _generatePermutations = function(array, buffer, start, end) {
      var index, range;
      if (end - start === 1) {
        buffer.push(array.concat());
      } else {
        range = end - start;
        index = 0;
        while (index < range) {
          swap(array, start, start + index);
          _generatePermutations(array, buffer, start + 1, end);
          swap(array, start, start + index);
          index++;
        }
      }
      return buffer;
    };
    return _generatePermutations(array.concat(), [], 0, array.length);
  };
  generateCombinations = function(array) {
    var combinations, index, _generateCombinations;
    _generateCombinations = function(start, array, combination, combinations) {
      var end;
      if (start === 0) {
        if (combination.length > 0) {
          combinations[combinations.length] = combination;
        }
        return;
      }
      end = 0;
      while (end < array.length) {
        _generateCombinations(start - 1, array.slice(end + 1), combination.concat([array[end]]), combinations);
        end++;
      }
    };
    combinations = [];
    index = 0;
    while (index < array.length) {
      _generateCombinations(index, array, [], combinations);
      index++;
    }
    combinations.push(array);
    return combinations;
  };
  wasSpyCalled = function(spy) {
    return spy.callCount !== 0;
  };
  wasSpyCalledWith = function(spy, value) {
    return jasmine.getEnv().contains_(spy.argsForCall, [value]);
  };
  beforeEach(function() {
    this.addMatchers({
      toBeInstanceOf: function(className) {
        return this.actual instanceof Ext.ClassManager.get(className);
      },
      toResolveWith: function(value) {
        var cancelCallback, failureCallback, progressCallback, successCallback;
        successCallback = jasmine.createSpy('success callback');
        failureCallback = jasmine.createSpy('failure callback');
        progressCallback = jasmine.createSpy('progress callback');
        cancelCallback = jasmine.createSpy('cancel callback');
        this.actual.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        return this.actual.getState() === 'resolved' && wasSpyCalledWith(successCallback, value) && !wasSpyCalled(failureCallback) && !wasSpyCalled(progressCallback) && !wasSpyCalled(cancelCallback);
      },
      toRejectWith: function(error) {
        var cancelCallback, failureCallback, progressCallback, successCallback;
        successCallback = jasmine.createSpy('success callback');
        failureCallback = jasmine.createSpy('failure callback');
        progressCallback = jasmine.createSpy('progress callback');
        cancelCallback = jasmine.createSpy('cancel callback');
        this.actual.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        return this.actual.getState() === 'rejected' && !wasSpyCalled(successCallback) && wasSpyCalledWith(failureCallback, error) && !wasSpyCalled(progressCallback) && !wasSpyCalled(cancelCallback);
      },
      toUpdateWith: function(progress) {
        var cancelCallback, failureCallback, progressCallback, successCallback;
        successCallback = jasmine.createSpy('success callback');
        failureCallback = jasmine.createSpy('failure callback');
        progressCallback = jasmine.createSpy('progress callback');
        cancelCallback = jasmine.createSpy('cancel callback');
        this.actual.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        return this.actual.getState() === 'pending' && !wasSpyCalled(successCallback) && !wasSpyCalled(failureCallback) && wasSpyCalledWith(progressCallback, progress) && !wasSpyCalled(cancelCallback);
      },
      toCancelWith: function(reason) {
        var cancelCallback, failureCallback, progressCallback, successCallback;
        successCallback = jasmine.createSpy('success callback');
        failureCallback = jasmine.createSpy('failure callback');
        progressCallback = jasmine.createSpy('progress callback');
        cancelCallback = jasmine.createSpy('cancel callback');
        this.actual.then({
          success: successCallback,
          failure: failureCallback,
          progress: progressCallback,
          cancel: cancelCallback
        });
        return this.actual.getState() === 'cancelled' && !wasSpyCalled(successCallback) && !wasSpyCalled(failureCallback) && !wasSpyCalled(progressCallback, reason) && wasSpyCalledWith(cancelCallback, reason);
      }
    });
  });
  describe('when()', function() {
    var MockThirdPartyPromise;
    MockThirdPartyPromise = (function() {

      function MockThirdPartyPromise() {}

      MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
        this.successCallback = successCallback;
        this.failureCallback = failureCallback;
        switch (this.state) {
          case 'resolved':
            this.successCallback(this.value);
            break;
          case 'rejected':
            this.failureCallback(this.value);
        }
      };

      MockThirdPartyPromise.prototype.resolve = function(value) {
        this.value = value;
        this.state = 'resolved';
        if (this.successCallback != null) {
          this.successCallback(this.value);
        }
      };

      MockThirdPartyPromise.prototype.reject = function(value) {
        this.value = value;
        this.state = 'rejected';
        if (this.failureCallback != null) {
          this.failureCallback(this.value);
        }
      };

      return MockThirdPartyPromise;

    })();
    it('should return an immediately resolved Promise when a value specified', function() {
      var promise;
      promise = Deft.promise.Promise.when('expected value');
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).toResolveWith('expected value');
    });
    it('should return a new resolved Promise when a resolved Promise is specified', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.resolve('expected value');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).toResolveWith('expected value');
    });
    it('should return a new rejected Promise when a rejected Promise is specified', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.reject('error message');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).toRejectWith('error message');
    });
    it('should return a new pending (and immediately updated) Promise when a pending (and updated) Promise is specified', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.update('progress');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).toUpdateWith('progress');
    });
    it('should return a new cancelled Promise when a cancelled Promise specified', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      deferred.cancel('reason');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).toCancelWith('reason');
    });
    it('should return a new pending Promise that resolves when the pending Promise specified is resolved', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      deferred.resolve('expected value');
      expect(promise).toResolveWith('expected value');
    });
    it('should return a new pending Promise that rejects when the pending Promise specified is rejected', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      deferred.reject('error message');
      expect(promise).toRejectWith('error message');
    });
    it('should return a new pending Promise that updates when the pending Promise specified is updated', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      deferred.update('progress');
      expect(promise).toUpdateWith('progress');
    });
    it('should return a new pending Promise that cancels when the pending Promise specified is cancelled', function() {
      var deferred, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = Deft.promise.Promise.when(deferred.getPromise());
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      deferred.cancel('reason');
      expect(promise).toCancelWith('reason');
    });
    it('should return a new resolved Promise when a resolved untrusted Promise is specified', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      mockThirdPartyPromise.resolve('expected value');
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(mockThirdPartyPromise);
      expect(promise).toResolveWith('expected value');
    });
    it('should return a new rejected Promise when a rejected untrusted Promise is specified', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      mockThirdPartyPromise.reject('error message');
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise).not.toBe(mockThirdPartyPromise);
      expect(promise).toRejectWith('error message');
    });
    it('should return a new Promise that resolves when the specified untrusted Promise is resolved', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(mockThirdPartyPromise);
      mockThirdPartyPromise.resolve('expected value');
      expect(promise).toResolveWith('expected value');
    });
    return it('should return a new Promise that rejects when the specified untrusted Promise is rejected', function() {
      var mockThirdPartyPromise, promise;
      mockThirdPartyPromise = new MockThirdPartyPromise();
      promise = Deft.promise.Promise.when(mockThirdPartyPromise);
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      expect(promise.getState()).toBe('pending');
      expect(promise).not.toBe(mockThirdPartyPromise);
      mockThirdPartyPromise.reject('error message');
      expect(promise).toRejectWith('error message');
    });
  });
  describe('all()', function() {
    describe('with an Array containing a single value', function() {
      var itShouldResolveForValue, value, values, _i, _len;
      itShouldResolveForValue = function(value) {
        it("should return an immediately resolved Promise when an Array containing '" + value + "' is specified", function() {
          var promise;
          promise = Deft.promise.Promise.all([value]);
          expect(promise).toBeInstanceOf('Deft.promise.Promise');
          expect(promise).toResolveWith([value]);
        });
      };
      values = [void 0, null, false, 0, 1, 'expected value', [], {}];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        itShouldResolveForValue.call(this, value);
      }
    });
    describe('with an Array containing a single Deferred', function() {
      it('should return a resolved Promise when an Array containing a single resolved Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.resolve('expected value');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toResolveWith(['expected value']);
      });
      it('should return a rejected Promise completed with the originating error when an Array containing a single rejected Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.reject('error message');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toRejectWith('error message');
      });
      it('should return a pending (and immediately updated) Promise when an Array containing a single pending (and updated) Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.update('progress');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toUpdateWith('progress');
      });
      it('should return a cancelled Promise completed with the originating reason when an Array containing a single cancelled Deferred is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.cancel('reason');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toCancelWith('reason');
      });
      it('should return a Promise that resolves when an Array containing a single Deferred is specified and that Deferred is resolved', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.resolve('expected value');
        expect(promise).toResolveWith(['expected value']);
      });
      it('should return a Promise that rejects when an Array containing a single Deferred is specified and that Deferred is rejected', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.reject('error message');
        expect(promise).toRejectWith('error message');
      });
      it('should return a Promise that updates when an Array containing a single Deferred is specified and that Deferred is updated', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.update('progress');
        expect(promise).toUpdateWith('progress');
      });
      return it('should return a Promise that cancels when an Array containing a single Deferred is specified and that Deferred is cancelled', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.cancel('reason');
        expect(promise).toCancelWith('reason');
      });
    });
    describe('with an Array containing a single Promise', function() {
      it('should return a resolved Promise when an Array containing a single resolved Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.resolve('expected value');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toResolveWith(['expected value']);
      });
      it('should return a rejected Promise completed with the originating error when an Array containing a single rejected Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.reject('error message');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toRejectWith('error message');
      });
      it('should return a pending (and immediately updated) Promise when an Array containing a single pending (and updated) Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.update('progress');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toUpdateWith('progress');
      });
      it('should return a cancelled Promise completed with the originating reason when an Array containing a single cancelled Promise is specified', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        deferred.cancel('reason');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise).toCancelWith('reason');
      });
      it('should return a Promise that resolves when an Array containing a single Promise is specified and that Promise is resolved', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.resolve('expected value');
        expect(promise).toResolveWith(['expected value']);
      });
      it('should return a Promise that rejects when an Array containing a single Promise is specified and that Promise is rejected', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.reject('error message');
        expect(promise).toRejectWith('error message');
      });
      it('should return a Promise that updates when an Array containing a single Promise is specified and that Promise is updated', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.update('progress');
        expect(promise).toUpdateWith('progress');
      });
      return it('should return a Promise that cancels when an Array containing a single Promise is specified and that Promise is cancelled', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.promise.Deferred');
        promise = Deft.promise.Promise.all([deferred.getPromise()]);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        expect(promise.getState()).toBe('pending');
        deferred.cancel('reason');
        expect(promise).toCancelWith('reason');
      });
    });
    describe('with multiple items specified', function() {
      var getInputParameters, getOutputParameters;
      getInputParameters = function(parameters) {
        var inputs, parameter, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(inputs = parameter.input);
        }
        return _results;
      };
      getOutputParameters = function(parameters) {
        var outputs, parameter, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(outputs = parameter.output);
        }
        return _results;
      };
      it('should return a resolved Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises is specified', function() {
        var combination, deferredB, deferredC, parameters, permutation, promise, promiseC, _i, _j, _len, _len1, _ref, _ref1;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith(getOutputParameters(permutation));
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of values, resolved or pending Deferreds, and/or resolved or pending Promises, and a rejected Deferred or Promise is specified', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, permutation, promise, promiseC, rejectedDeferred, rejectedDeferredParameter, rejectedPromiseParameter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }, {
            input: pendingDeferred
          }, {
            input: pendingDeferred.getPromise()
          }
        ];
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        rejectedDeferredParameter = {
          input: rejectedDeferred,
          output: 'error message'
        };
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(rejectedDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toRejectWith('error message');
          }
        }
        rejectedPromiseParameter = {
          input: rejectedDeferred.getPromise(),
          output: 'error message'
        };
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(rejectedPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.all(getInputParameters(permutation));
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toRejectWith('error message'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a pending (and immediately updated) Promise when an Array containing any combination of values, resolved or pending Deferreds, and/or resolved or pending Promises, and pending (and updated) Deferred or Promise is specified', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, permutation, promise, promiseC, updatedDeferred, updatedDeferredParameter, updatedPromiseParameter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }, {
            input: pendingDeferred
          }, {
            input: pendingDeferred.getPromise()
          }
        ];
        updatedDeferred = Ext.create('Deft.promise.Deferred');
        updatedDeferred.update('progress');
        updatedDeferredParameter = {
          input: updatedDeferred,
          output: 'progress'
        };
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(updatedDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toUpdateWith('progress');
          }
        }
        updatedPromiseParameter = {
          input: updatedDeferred.getPromise(),
          output: 'progress'
        };
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(updatedPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.all(getInputParameters(permutation));
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toUpdateWith('progress'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a cancelled Promise when an Array containing any combination of values, resolved or pending Deferreds, and/or resolved or pending Promises, and a cancelled Deferred or Promise is specified', function() {
        var cancelledDeferred, cancelledDeferredParameter, cancelledPromiseParameter, combination, deferredB, deferredC, parameters, pendingDeferred, permutation, promise, promiseC, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }, {
            input: pendingDeferred
          }, {
            input: pendingDeferred.getPromise()
          }
        ];
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        cancelledDeferredParameter = {
          input: cancelledDeferred,
          output: 'reason'
        };
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(cancelledDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toCancelWith('reason');
          }
        }
        cancelledPromiseParameter = {
          input: cancelledDeferred.getPromise(),
          output: 'reason'
        };
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(cancelledPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.all(getInputParameters(permutation));
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toCancelWith('reason'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a resolved Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is resolved', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'expected value'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.resolve('expected value');
            expect(promise).toResolveWith(getOutputParameters(permutation));
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'expected value'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.resolve('expected value');
            expect(promise).toResolveWith(getOutputParameters(permutation));
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is rejected', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.reject('error message');
            expect(promise).toRejectWith('error message');
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.reject('error message');
            expect(promise).toRejectWith('error message');
          }
        }
      });
      it('should return a pending (and later updated) when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred is updated', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.update('progress');
            expect(promise).toUpdateWith('progress');
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.update('progress');
            expect(promise).toUpdateWith('progress');
          }
        }
      });
      it('should return a cancelled Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is cancelled', function() {
        var combination, deferredB, deferredC, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promiseC, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferredB = Ext.create('Deft.promise.Deferred');
        deferredB.resolve('B');
        deferredC = Ext.create('Deft.promise.Deferred');
        deferredC.resolve('C');
        promiseC = deferredC.getPromise();
        parameters = [
          {
            input: 'A',
            output: 'A'
          }, {
            input: deferredB,
            output: 'B'
          }, {
            input: promiseC,
            output: 'C'
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'reason'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.cancel('reason');
            expect(promise).toCancelWith('reason');
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.all(getInputParameters(permutation));
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.cancel('reason');
            expect(promise).toCancelWith('reason');
          }
        }
      });
    });
  });
  describe('any()', function() {
    describe('with an Array containing a single value of any type', function() {
      var itShouldResolveForValue, value, values, _i, _len;
      itShouldResolveForValue = function(value) {
        it("should return an immediately resolved Promise when an Array containing '" + value + "' is specified", function() {
          var promise;
          promise = Deft.promise.Promise.any([value]);
          expect(promise).toBeInstanceOf('Deft.promise.Promise');
          expect(promise).toResolveWith(value);
        });
      };
      values = [void 0, null, false, 0, 1, 'expected value', [], {}];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        itShouldResolveForValue.call(this, value);
      }
    });
    describe('with a variety of combinations of values, Deferreds and Promises specified', function() {
      it('should return a resolved Promise when an Array containing any combination of pending, rejected and/or cancelled Deferreds and/or Promises, and a value is specified', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, promise, rejectedDeferred, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [pendingDeferred, pendingDeferred.getPromise(), rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat('expected result'));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith('expected result');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat('expected result'));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith('expected result');
          }
        }
      });
      it('should return a resolved Promise when an Array containing any combination of pending, rejected and/or cancelled Deferreds and/or Promises, and a resolved Deferred or Promise is specified', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, promise, rejectedDeferred, resolvedDeferred, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [pendingDeferred, pendingDeferred.getPromise(), rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        resolvedDeferred = Ext.create('Deft.promise.Deferred');
        resolvedDeferred.resolve('expected result');
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(resolvedDeferred));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith('expected result');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(resolvedDeferred.getPromise()));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith('expected result');
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of rejected and/or cancelled Deferreds and/or Promises is specified', function() {
        var cancelledDeferred, combination, parameters, permutation, promise, rejectedDeferred, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toRejectWith(new Error('No Promises were resolved.'));
          }
        }
        _ref2 = generateCombinations(parameters);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination);
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.any(permutation);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toRejectWith(new Error('No Promises were resolved.')));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a pending (and immediately updated) Promise when an Array containing any combination of pending, rejected and/or cancelled Deferreds and/or Promises, and a pending (and updated) Deferred or Promise is specified', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, promise, rejectedDeferred, updatedDeferred, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [pendingDeferred, pendingDeferred.getPromise(), rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        updatedDeferred = Ext.create('Deft.promise.Deferred');
        updatedDeferred.update('progress');
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(updatedDeferred));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toUpdateWith('progress');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(updatedDeferred.getPromise()));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.any(permutation);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toUpdateWith('progress'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a resolved Promise when an Array containing any combination of pending, rejected and/or cancelled Deferreds and/or Promises, and a pending Deferred or Promise is specified that is later resolved', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, placeholder, promise, rejectedDeferred, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [pendingDeferred, pendingDeferred.getPromise(), rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred;
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.resolve('expected value');
            expect(promise).toResolveWith('expected value');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred.getPromise();
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.resolve('expected value');
            expect(promise).toResolveWith('expected value');
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of rejected and/or cancelled Deferreds and/or Promises, and a pending Deferred or Promise is specified that is later rejected', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, placeholder, promise, rejectedDeferred, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred;
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.reject('error message');
            expect(promise).toRejectWith(new Error('No Promises were resolved.'));
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred.getPromise();
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.reject('error message');
            expect(promise).toRejectWith(new Error('No Promises were resolved.'));
          }
        }
      });
      it('should return a pending (and later updated) when an Array containing any combination of pending, rejected and/or Deferreds and/or Promises, and a pending Deferred or Promise is specified that is later updated', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, placeholder, promise, rejectedDeferred, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        pendingDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [pendingDeferred, pendingDeferred.getPromise(), rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred;
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.update('progress');
            expect(promise).toUpdateWith('progress');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred.getPromise();
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.update('progress');
            expect(promise).toUpdateWith('progress');
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of rejected and/or cancelled Deferreds and/or Promises, and a pending Deferred or Promise is specified that is later cancelled', function() {
        var cancelledDeferred, combination, parameters, pendingDeferred, permutation, placeholder, promise, rejectedDeferred, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        parameters = [rejectedDeferred, rejectedDeferred.getPromise(), cancelledDeferred, cancelledDeferred.getPromise()];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred;
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.cancel('reason');
            expect(promise).toRejectWith(new Error('No Promises were resolved.'));
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferred.getPromise();
            promise = Deft.promise.Promise.any(permutation);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.cancel('reason');
            expect(promise).toRejectWith(new Error('No Promises were resolved.'));
          }
        }
      });
    });
  });
  describe('memoize()', function() {
    var createSpecsForScope, fibonacci;
    fibonacci = function(n) {
      if (n < 2) {
        return n;
      } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
    };
    createSpecsForScope = function(expectedScope) {
      var createTargetFunction;
      createTargetFunction = function() {
        return jasmine.createSpy('target function').andCallFake(function() {
          if (expectedScope != null) {
            expect(this).toBe(expectedScope);
          } else {
            expect(this).toBe(window);
          }
          return fibonacci.apply(this, arguments);
        });
      };
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a resolved Promise when the input is a value', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        promise = memoFunction(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        promise = memoFunction(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a resolved Promise when the input is a resolved Deferred or Promise', function() {
        var memoFunction, promise, resolvedDeferred, resolvedPromise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        resolvedDeferred = new Ext.create('Deft.promise.Deferred');
        resolvedDeferred.resolve(12);
        promise = memoFunction(resolvedDeferred);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        promise = memoFunction(resolvedDeferred);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        promise = memoFunction(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        resolvedPromise = resolvedDeferred.getPromise();
        promise = memoFunction(resolvedPromise);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        resolvedPromise = resolvedDeferred.getPromise();
        promise = memoFunction(resolvedPromise);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        promise = memoFunction(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a rejected Promise when the input is a rejected Deferred or Promise', function() {
        var memoFunction, promise, rejectedDeferred, rejectedPromise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        rejectedDeferred = new Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        promise = memoFunction(rejectedDeferred);
        expect(promise).toRejectWith('error message');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        rejectedPromise = rejectedDeferred.getPromise();
        promise = memoFunction(rejectedPromise);
        expect(promise).toRejectWith('error message');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending (and immediately updated) Promise when the input is a pending (and updated) Deferred or Promise', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingDeferred.update('progress');
        promise = memoFunction(pendingDeferred);
        expect(promise).toUpdateWith('progress');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingPromise = pendingDeferred.getPromise();
        promise = memoFunction(pendingPromise);
        expect(promise).toUpdateWith('progress');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a cancelled Promise when the input is a cancelled Deferred or Promise', function() {
        var cancelledDeferred, cancelledPromise, memoFunction, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        cancelledDeferred = new Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        promise = memoFunction(cancelledDeferred);
        expect(promise).toCancelWith('reason');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        cancelledPromise = cancelledDeferred.getPromise();
        promise = memoFunction(cancelledPromise);
        expect(promise).toCancelWith('reason');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise resolves when the specified Deferred or Promise is resolved', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        promise = memoFunction(pendingDeferred);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        promise = memoFunction(pendingDeferred);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        promise = memoFunction(pendingPromise);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).toHaveBeenCalled();
        targetFunction.reset();
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        promise = memoFunction(pendingPromise);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.resolve(12);
        expect(promise).toResolveWith(fibonacci(12));
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise rejects when the specified Deferred or Promise is rejected', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        promise = memoFunction(pendingDeferred);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.reject('error message');
        expect(promise).toRejectWith('error message');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        promise = memoFunction(pendingPromise);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.reject('error message');
        expect(promise).toRejectWith('error message');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise updates when the specified Deferred or Promise is updated', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        promise = memoFunction(pendingDeferred);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.update('progress');
        expect(promise).toUpdateWith('progress');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        promise = memoFunction(pendingPromise);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.update('progress');
        expect(promise).toUpdateWith('progress');
        expect(targetFunction).not.toHaveBeenCalled();
      });
      it('should return a new function that wraps the specified function and caches the results for previously processed inputs, and returns a pending Promise when the input is a pending Deferred or Promise, and where that pending Promise cancels when the specified Deferred or Promise is cancelled', function() {
        var memoFunction, pendingDeferred, pendingPromise, promise, targetFunction;
        targetFunction = createTargetFunction();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        promise = memoFunction(pendingDeferred);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.cancel('reason');
        expect(promise).toCancelWith('reason');
        expect(targetFunction).not.toHaveBeenCalled();
        memoFunction = Deft.promise.Promise.memoize(targetFunction, expectedScope);
        pendingDeferred = new Ext.create('Deft.promise.Deferred');
        pendingPromise = pendingDeferred.getPromise();
        promise = memoFunction(pendingPromise);
        expect(promise.getState()).toBe('pending');
        pendingDeferred.cancel('reason');
        expect(promise).toCancelWith('reason');
        expect(targetFunction).not.toHaveBeenCalled();
      });
    };
    describe('(omitting the optional scope and hash function parameters)', function() {
      createSpecsForScope();
    });
    describe('(specifying the scope to execute the memoized function in via the optional scope parameter)', function() {
      var expectedScope;
      expectedScope = {};
      createSpecsForScope(expectedScope);
    });
  });
  describe('map()', function() {
    var doubleFunction, getInputParameters, getOutputParameters, identityFunction;
    identityFunction = function(value) {
      return value;
    };
    doubleFunction = function(value) {
      return value * 2;
    };
    getInputParameters = function(parameters) {
      var inputs, parameter, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = parameters.length; _i < _len; _i++) {
        parameter = parameters[_i];
        _results.push(inputs = parameter.input);
      }
      return _results;
    };
    getOutputParameters = function(parameters) {
      var outputs, parameter, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = parameters.length; _i < _len; _i++) {
        parameter = parameters[_i];
        _results.push(outputs = parameter.output);
      }
      return _results;
    };
    describe('with an Array of values and a mapping function specified', function() {
      it('should return a resolved Promise with the mapped values', function() {
        var combination, expectedMappedValues, mapFunction, parameters, permutation, promise, values, _i, _len, _ref, _results;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _results.push((function() {
            var _j, _len1, _ref1, _results1;
            _ref1 = generatePermutations(combination);
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              permutation = _ref1[_j];
              values = getInputParameters(permutation);
              expectedMappedValues = getOutputParameters(permutation);
              mapFunction = function(value, index, array) {
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                return doubleFunction(value);
              };
              promise = Deft.promise.Promise.map(values, mapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toResolveWith(expectedMappedValues));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a resolved Promise with the mapped values for any valid input value type', function() {
        var mapFunction, promise, values;
        values = [void 0, null, false, 0, 1, 'expected value', [], {}];
        mapFunction = function(value, index, array) {
          expect(array).toBe(values);
          expect(value).toBe(array[index]);
          return identityFunction(value);
        };
        promise = Deft.promise.Promise.map(values, mapFunction);
        expect(promise).toBeInstanceOf('Deft.promise.Promise');
        return expect(promise).toResolveWith(values);
      });
    });
    describe('with an Array of values and a mapping function that returns a Deferred or Promise specified', function() {
      it('should return a resolved Promise with the resolved mapped values if the mapping function returns resolved Deferreds or Promises', function() {
        var combination, deferredMapFunction, expectedMappedValues, parameters, permutation, promise, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            values = getInputParameters(permutation);
            expectedMappedValues = getOutputParameters(permutation);
            deferredMapFunction = function(value, index, array) {
              var deferred;
              expect(array).toBe(values);
              expect(value).toBe(array[index]);
              deferred = Ext.create('Deft.promise.Deferred');
              deferred.resolve(doubleFunction(value));
              return deferred;
            };
            promise = Deft.promise.Promise.map(values, deferredMapFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith(expectedMappedValues);
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination);
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            values = getInputParameters(permutation);
            expectedMappedValues = getOutputParameters(permutation);
            deferredMapFunction = function(value, index, array) {
              var deferred;
              expect(array).toBe(values);
              expect(value).toBe(array[index]);
              deferred = Ext.create('Deft.promise.Deferred');
              deferred.resolve(doubleFunction(value));
              return deferred.getPromise();
            };
            promise = Deft.promise.Promise.map(values, deferredMapFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith(expectedMappedValues);
          }
        }
      });
      it('should return a rejected Promise with the associated error message if the mapping function returns a rejected Deferred or Promise', function() {
        var combination, deferredMapFunction, parameters, permutation, promise, rejectedIndex, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            for (rejectedIndex = _k = 0, _ref2 = permutation.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; rejectedIndex = 0 <= _ref2 ? ++_k : --_k) {
              values = getInputParameters(permutation);
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                if (index === rejectedIndex) {
                  deferred.reject('error message');
                } else {
                  deferred.resolve(doubleFunction(value));
                }
                return deferred;
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise).toRejectWith('error message');
            }
          }
        }
        _ref3 = generateCombinations(parameters);
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          combination = _ref3[_l];
          _ref4 = generatePermutations(combination);
          for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
            permutation = _ref4[_m];
            for (rejectedIndex = _n = 0, _ref5 = permutation.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; rejectedIndex = 0 <= _ref5 ? ++_n : --_n) {
              values = getInputParameters(permutation);
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                if (index === rejectedIndex) {
                  deferred.reject('error message');
                } else {
                  deferred.resolve(doubleFunction(value));
                }
                return deferred.getPromise();
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise).toRejectWith('error message');
            }
          }
        }
      });
      it('should return a pending (and immediately updated) Promise with the associated progress update if the mapping function returns a pending (and updated) Deferred or Promise', function() {
        var combination, deferredMapFunction, parameters, permutation, promise, updatedIndex, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            for (updatedIndex = _k = 0, _ref2 = permutation.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; updatedIndex = 0 <= _ref2 ? ++_k : --_k) {
              values = getInputParameters(permutation);
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                if (index === updatedIndex) {
                  deferred.update('progress');
                } else {
                  deferred.resolve(doubleFunction(value));
                }
                return deferred;
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise).toUpdateWith('progress');
            }
          }
        }
        _ref3 = generateCombinations(parameters);
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          combination = _ref3[_l];
          _ref4 = generatePermutations(combination);
          for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
            permutation = _ref4[_m];
            for (updatedIndex = _n = 0, _ref5 = permutation.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; updatedIndex = 0 <= _ref5 ? ++_n : --_n) {
              values = getInputParameters(permutation);
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                if (index === updatedIndex) {
                  deferred.update('progress');
                } else {
                  deferred.resolve(doubleFunction(value));
                }
                return deferred.getPromise();
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise).toUpdateWith('progress');
            }
          }
        }
      });
      it('should return a cancelled Promise with the associated reason if the mapping function returns a cancelled Deferred or Promise', function() {
        var canceledIndex, combination, deferredMapFunction, parameters, permutation, promise, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            for (canceledIndex = _k = 0, _ref2 = permutation.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; canceledIndex = 0 <= _ref2 ? ++_k : --_k) {
              values = getInputParameters(permutation);
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                if (index === canceledIndex) {
                  deferred.cancel('reason');
                } else {
                  deferred.resolve(doubleFunction(value));
                }
                return deferred;
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise).toCancelWith('reason');
            }
          }
        }
        _ref3 = generateCombinations(parameters);
        for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
          combination = _ref3[_l];
          _ref4 = generatePermutations(combination);
          for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
            permutation = _ref4[_m];
            for (canceledIndex = _n = 0, _ref5 = permutation.length; 0 <= _ref5 ? _n < _ref5 : _n > _ref5; canceledIndex = 0 <= _ref5 ? ++_n : --_n) {
              values = getInputParameters(permutation);
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                if (index === canceledIndex) {
                  deferred.cancel('reason');
                } else {
                  deferred.resolve(doubleFunction(value));
                }
                return deferred.getPromise();
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise).toCancelWith('reason');
            }
          }
        }
      });
      it('should return a pending Promise that resolves with the resolved mapped values when all of the pending Deferreds or Promises returned by the mapping function resolve', function() {
        var combination, deferredMapFunction, deferredMapFunctionOperation, deferredMapFunctionOperations, expectedMappedValues, parameters, permutation, promise, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            values = getInputParameters(permutation);
            expectedMappedValues = getOutputParameters(permutation);
            deferredMapFunctionOperations = [];
            deferredMapFunction = function(value, index, array) {
              var deferred;
              expect(array).toBe(values);
              expect(value).toBe(array[index]);
              deferred = Ext.create('Deft.promise.Deferred');
              deferredMapFunctionOperations.push(function() {
                deferred.resolve(doubleFunction(value));
              });
              return deferred;
            };
            promise = Deft.promise.Promise.map(values, deferredMapFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            for (_k = 0, _len2 = deferredMapFunctionOperations.length; _k < _len2; _k++) {
              deferredMapFunctionOperation = deferredMapFunctionOperations[_k];
              deferredMapFunctionOperation();
            }
            expect(promise).toResolveWith(expectedMappedValues);
          }
        }
        _ref2 = generateCombinations(parameters);
        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
          combination = _ref2[_l];
          _ref3 = generatePermutations(combination);
          for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
            permutation = _ref3[_m];
            values = getInputParameters(permutation);
            expectedMappedValues = getOutputParameters(permutation);
            deferredMapFunctionOperations = [];
            deferredMapFunction = function(value, index, array) {
              var deferred;
              expect(array).toBe(values);
              expect(value).toBe(array[index]);
              deferred = Ext.create('Deft.promise.Deferred');
              deferredMapFunctionOperations.push(function() {
                deferred.resolve(doubleFunction(value));
              });
              return deferred.getPromise();
            };
            promise = Deft.promise.Promise.map(values, deferredMapFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            for (_n = 0, _len5 = deferredMapFunctionOperations.length; _n < _len5; _n++) {
              deferredMapFunctionOperation = deferredMapFunctionOperations[_n];
              deferredMapFunctionOperation();
            }
            expect(promise).toResolveWith(expectedMappedValues);
          }
        }
      });
      it('should return a pending Promise that rejects when any of the pending Deferreds or Promises returned by the mapping function rejects', function() {
        var combination, deferredMapFunction, deferredMapFunctionOperation, deferredMapFunctionOperations, parameters, permutation, promise, rejectedIndex, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            for (rejectedIndex = _k = 0, _ref2 = permutation.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; rejectedIndex = 0 <= _ref2 ? ++_k : --_k) {
              values = getInputParameters(permutation);
              deferredMapFunctionOperations = [];
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                deferredMapFunctionOperations.push(function() {
                  if (index === rejectedIndex) {
                    deferred.reject('error message');
                  } else {
                    deferred.resolve(doubleFunction(value));
                  }
                });
                return deferred;
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              for (_l = 0, _len2 = deferredMapFunctionOperations.length; _l < _len2; _l++) {
                deferredMapFunctionOperation = deferredMapFunctionOperations[_l];
                deferredMapFunctionOperation();
              }
              expect(promise).toRejectWith('error message');
            }
          }
        }
        _ref3 = generateCombinations(parameters);
        for (_m = 0, _len3 = _ref3.length; _m < _len3; _m++) {
          combination = _ref3[_m];
          _ref4 = generatePermutations(combination);
          for (_n = 0, _len4 = _ref4.length; _n < _len4; _n++) {
            permutation = _ref4[_n];
            for (rejectedIndex = _o = 0, _ref5 = permutation.length; 0 <= _ref5 ? _o < _ref5 : _o > _ref5; rejectedIndex = 0 <= _ref5 ? ++_o : --_o) {
              values = getInputParameters(permutation);
              deferredMapFunctionOperations = [];
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                deferredMapFunctionOperations.push(function() {
                  if (index === rejectedIndex) {
                    deferred.reject('error message');
                  } else {
                    deferred.resolve(doubleFunction(value));
                  }
                });
                return deferred.getPromise();
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              for (_p = 0, _len5 = deferredMapFunctionOperations.length; _p < _len5; _p++) {
                deferredMapFunctionOperation = deferredMapFunctionOperations[_p];
                deferredMapFunctionOperation();
              }
              expect(promise).toRejectWith('error message');
            }
          }
        }
      });
      it('should return a pending Promise that updates when any of the pending Deferreds or Promises returned by the mapping function updates', function() {
        var combination, deferredMapFunction, deferredMapFunctionOperation, deferredMapFunctionOperations, parameters, permutation, promise, updatedIndex, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            for (updatedIndex = _k = 0, _ref2 = permutation.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; updatedIndex = 0 <= _ref2 ? ++_k : --_k) {
              values = getInputParameters(permutation);
              deferredMapFunctionOperations = [];
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                deferredMapFunctionOperations.push(function() {
                  if (index === updatedIndex) {
                    deferred.update('progress');
                  } else {
                    deferred.resolve(doubleFunction(value));
                  }
                });
                return deferred;
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              for (_l = 0, _len2 = deferredMapFunctionOperations.length; _l < _len2; _l++) {
                deferredMapFunctionOperation = deferredMapFunctionOperations[_l];
                deferredMapFunctionOperation();
              }
              expect(promise).toUpdateWith('progress');
            }
          }
        }
        _ref3 = generateCombinations(parameters);
        for (_m = 0, _len3 = _ref3.length; _m < _len3; _m++) {
          combination = _ref3[_m];
          _ref4 = generatePermutations(combination);
          for (_n = 0, _len4 = _ref4.length; _n < _len4; _n++) {
            permutation = _ref4[_n];
            for (updatedIndex = _o = 0, _ref5 = permutation.length; 0 <= _ref5 ? _o < _ref5 : _o > _ref5; updatedIndex = 0 <= _ref5 ? ++_o : --_o) {
              values = getInputParameters(permutation);
              deferredMapFunctionOperations = [];
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                deferredMapFunctionOperations.push(function() {
                  if (index === updatedIndex) {
                    deferred.update('progress');
                  } else {
                    deferred.resolve(doubleFunction(value));
                  }
                });
                return deferred.getPromise();
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              for (_p = 0, _len5 = deferredMapFunctionOperations.length; _p < _len5; _p++) {
                deferredMapFunctionOperation = deferredMapFunctionOperations[_p];
                deferredMapFunctionOperation();
              }
              expect(promise).toUpdateWith('progress');
            }
          }
        }
      });
      it('should return a pending Promise that cancels when any of the pending Deferreds or Promises returned by the mapping function cancels', function() {
        var canceledIndex, combination, deferredMapFunction, deferredMapFunctionOperation, deferredMapFunctionOperations, parameters, permutation, promise, values, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: 2,
            output: 4
          }, {
            input: 3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            for (canceledIndex = _k = 0, _ref2 = permutation.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; canceledIndex = 0 <= _ref2 ? ++_k : --_k) {
              values = getInputParameters(permutation);
              deferredMapFunctionOperations = [];
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                deferredMapFunctionOperations.push(function() {
                  if (index === canceledIndex) {
                    deferred.cancel('reason');
                  } else {
                    deferred.resolve(doubleFunction(value));
                  }
                });
                return deferred;
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              for (_l = 0, _len2 = deferredMapFunctionOperations.length; _l < _len2; _l++) {
                deferredMapFunctionOperation = deferredMapFunctionOperations[_l];
                deferredMapFunctionOperation();
              }
              expect(promise).toCancelWith('reason');
            }
          }
        }
        _ref3 = generateCombinations(parameters);
        for (_m = 0, _len3 = _ref3.length; _m < _len3; _m++) {
          combination = _ref3[_m];
          _ref4 = generatePermutations(combination);
          for (_n = 0, _len4 = _ref4.length; _n < _len4; _n++) {
            permutation = _ref4[_n];
            for (canceledIndex = _o = 0, _ref5 = permutation.length; 0 <= _ref5 ? _o < _ref5 : _o > _ref5; canceledIndex = 0 <= _ref5 ? ++_o : --_o) {
              values = getInputParameters(permutation);
              deferredMapFunctionOperations = [];
              deferredMapFunction = function(value, index, array) {
                var deferred;
                expect(array).toBe(values);
                expect(value).toBe(array[index]);
                deferred = Ext.create('Deft.promise.Deferred');
                deferredMapFunctionOperations.push(function() {
                  if (index === canceledIndex) {
                    deferred.cancel('reason');
                  } else {
                    deferred.resolve(doubleFunction(value));
                  }
                });
                return deferred.getPromise();
              };
              promise = Deft.promise.Promise.map(values, deferredMapFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              expect(promise.getState()).toBe('pending');
              for (_p = 0, _len5 = deferredMapFunctionOperations.length; _p < _len5; _p++) {
                deferredMapFunctionOperation = deferredMapFunctionOperations[_p];
                deferredMapFunctionOperation();
              }
              expect(promise).toCancelWith('reason');
            }
          }
        }
      });
    });
    return describe('with a variety of combinations of values, Deferreds and Promises and a mapping function specified', function() {
      getInputParameters = function(parameters) {
        var inputs, parameter, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(inputs = parameter.input);
        }
        return _results;
      };
      getOutputParameters = function(parameters) {
        var outputs, parameter, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(outputs = parameter.output);
        }
        return _results;
      };
      it('should return a resolved Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises is specified', function() {
        var combination, deferred2, deferred3, parameters, permutation, promise, promise3, _i, _j, _len, _len1, _ref, _ref1;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        _ref = generateCombinations(parameters);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toResolveWith(getOutputParameters(permutation));
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of values, resolved Deferreds, and/or resolved Promises, and a rejected Deferred or Promise is specified', function() {
        var combination, deferred2, deferred3, parameters, permutation, promise, promise3, rejectedDeferred, rejectedDeferredParameter, rejectedPromiseParameter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        rejectedDeferred = Ext.create('Deft.promise.Deferred');
        rejectedDeferred.reject('error message');
        rejectedDeferredParameter = {
          input: rejectedDeferred,
          output: 'error message'
        };
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(rejectedDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toRejectWith('error message');
          }
        }
        rejectedPromiseParameter = {
          input: rejectedDeferred.getPromise(),
          output: 'error message'
        };
        _ref2 = generateCombinations(parameters).concat([]);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(rejectedPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toRejectWith('error message'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a pending (and immediately updated) Promise when an Array containing any combination of values, resolved Deferreds, and/or resolved Promises, and pending (and updated) Deferred or Promise is specified', function() {
        var combination, deferred2, deferred3, parameters, permutation, promise, promise3, updatedDeferred, updatedDeferredParameter, updatedPromiseParameter, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        updatedDeferred = Ext.create('Deft.promise.Deferred');
        updatedDeferred.update('progress');
        updatedDeferredParameter = {
          input: updatedDeferred,
          output: 'progress'
        };
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(updatedDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toUpdateWith('progress');
          }
        }
        updatedPromiseParameter = {
          input: updatedDeferred.getPromise(),
          output: 'progress'
        };
        _ref2 = generateCombinations(parameters).concat([]);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(updatedPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toUpdateWith('progress'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a cancelled Promise when an Array containing any combination of values, resolved Deferreds, and/or resolved Promises, and a cancelled Deferred or Promise is specified', function() {
        var cancelledDeferred, cancelledDeferredParameter, cancelledPromiseParameter, combination, deferred2, deferred3, parameters, permutation, promise, promise3, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        cancelledDeferred = Ext.create('Deft.promise.Deferred');
        cancelledDeferred.cancel('reason');
        cancelledDeferredParameter = {
          input: cancelledDeferred,
          output: 'reason'
        };
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(cancelledDeferredParameter));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise).toCancelWith('reason');
          }
        }
        cancelledPromiseParameter = {
          input: cancelledDeferred.getPromise(),
          output: 'reason'
        };
        _ref2 = generateCombinations(parameters).concat([]);
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = generatePermutations(combination.concat(cancelledPromiseParameter));
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              permutation = _ref3[_l];
              promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
              expect(promise).toBeInstanceOf('Deft.promise.Promise');
              _results1.push(expect(promise).toCancelWith('reason'));
            }
            return _results1;
          })());
        }
        return _results;
      });
      it('should return a resolved Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is resolved', function() {
        var combination, deferred2, deferred3, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promise3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 8
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.resolve(4);
            expect(promise).toResolveWith(getOutputParameters(permutation));
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 8
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.resolve(4);
            expect(promise).toResolveWith(getOutputParameters(permutation));
          }
        }
      });
      it('should return a rejected Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is rejected', function() {
        var combination, deferred2, deferred3, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promise3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.reject('error message');
            expect(promise).toRejectWith('error message');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.reject('error message');
            expect(promise).toRejectWith('error message');
          }
        }
      });
      it('should return a pending (and later updated) when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred is updated', function() {
        var combination, deferred2, deferred3, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promise3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.update('progress');
            expect(promise).toUpdateWith('progress');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.update('progress');
            expect(promise).toUpdateWith('progress');
          }
        }
      });
      it('should return a cancelled Promise when an Array containing any combination of values, resolved Deferreds and/or resolved Promises, and a pending Deferred or Promise is specified, and that pending Deferred or Promise is cancelled', function() {
        var combination, deferred2, deferred3, parameters, pendingDeferred, pendingDeferredParameter, pendingPromiseParameter, permutation, placeholder, promise, promise3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
        deferred2 = Ext.create('Deft.promise.Deferred');
        deferred2.resolve(2);
        deferred3 = Ext.create('Deft.promise.Deferred');
        deferred3.resolve(3);
        promise3 = deferred3.getPromise();
        parameters = [
          {
            input: 1,
            output: 2
          }, {
            input: deferred2,
            output: 4
          }, {
            input: promise3,
            output: 6
          }
        ];
        placeholder = {};
        _ref = generateCombinations(parameters).concat([]);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          combination = _ref[_i];
          _ref1 = generatePermutations(combination.concat(placeholder));
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            permutation = _ref1[_j];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingDeferredParameter = {
              input: pendingDeferred,
              output: 'reason'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingDeferredParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.cancel('reason');
            expect(promise).toCancelWith('reason');
          }
        }
        _ref2 = generateCombinations(parameters).concat([]);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          combination = _ref2[_k];
          _ref3 = generatePermutations(combination.concat(placeholder));
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            permutation = _ref3[_l];
            pendingDeferred = Ext.create('Deft.promise.Deferred');
            pendingPromiseParameter = {
              input: pendingDeferred.getPromise(),
              output: 'error message'
            };
            permutation[Ext.Array.indexOf(permutation, placeholder)] = pendingPromiseParameter;
            promise = Deft.promise.Promise.map(getInputParameters(permutation), doubleFunction);
            expect(promise).toBeInstanceOf('Deft.promise.Promise');
            expect(promise.getState()).toBe('pending');
            pendingDeferred.cancel('reason');
            expect(promise).toCancelWith('reason');
          }
        }
      });
    });
  });
  describe('reduce()', function() {
    var sumFunction;
    sumFunction = function(previousValue, currentValue, index, array) {
      return previousValue + currentValue;
    };
    it('should reduce input values to a corresponding output value using a reduce function (with no initial value specified)', function() {
      var promise, values;
      values = [0, 1, 2, 3, 4];
      promise = Deft.promise.Promise.reduce(values, sumFunction);
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      return expect(promise).toResolveWith(10);
    });
    return it('should reduce input values to a corresponding output value using a reduce function (with an initial value specified)', function() {
      var promise, values;
      values = [0, 1, 2, 3, 4];
      promise = Deft.promise.Promise.reduce(values, sumFunction, 10);
      expect(promise).toBeInstanceOf('Deft.promise.Promise');
      return expect(promise).toResolveWith(20);
    });
  });
  describe('then()', function() {
    var cancelCallback, failureCallback, progressCallback, scope, successCallback;
    successCallback = failureCallback = progressCallback = cancelCallback = scope = null;
    beforeEach(function() {
      successCallback = jasmine.createSpy('success callback');
      failureCallback = jasmine.createSpy('failure callback');
      progressCallback = jasmine.createSpy('progress callback');
      cancelCallback = jasmine.createSpy('cancel callback');
      scope = {};
    });
    return it('should call through to the underlying Deferred\'s then() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'then').andReturn(expectedReturnValue);
      expect(promise.then(successCallback, failureCallback, progressCallback, cancelCallback, scope)).toBe(expectedReturnValue);
      expect(deferred.then).toHaveBeenCalledWith(successCallback, failureCallback, progressCallback, cancelCallback, scope);
      expect(promise.then({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback,
        scope: scope
      })).toBe(expectedReturnValue);
      expect(deferred.then).toHaveBeenCalledWith({
        success: successCallback,
        failure: failureCallback,
        progress: progressCallback,
        cancel: cancelCallback,
        scope: scope
      });
    });
  });
  describe('otherwise()', function() {
    var otherwiseCallback, scope;
    otherwiseCallback = scope = null;
    beforeEach(function() {
      otherwiseCallback = jasmine.createSpy('otherwise callback');
      scope = {};
    });
    return it('should call through to the underlying Deferred\'s otherwise() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'otherwise').andReturn(expectedReturnValue);
      expect(promise.otherwise(otherwiseCallback, scope)).toBe(expectedReturnValue);
      expect(deferred.otherwise).toHaveBeenCalledWith(otherwiseCallback, scope);
      expect(promise.otherwise({
        fn: otherwiseCallback,
        scope: scope
      })).toBe(expectedReturnValue);
      expect(deferred.otherwise).toHaveBeenCalledWith({
        fn: otherwiseCallback,
        scope: scope
      });
    });
  });
  describe('always()', function() {
    var alwaysCallback, scope;
    alwaysCallback = scope = null;
    beforeEach(function() {
      alwaysCallback = jasmine.createSpy('always callback');
      scope = {};
    });
    return it('should call through to the underlying Deferred\'s otherwise() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'always').andReturn(expectedReturnValue);
      expect(promise.always(alwaysCallback, scope)).toBe(expectedReturnValue);
      expect(deferred.always).toHaveBeenCalledWith(alwaysCallback, scope);
      expect(promise.always({
        fn: alwaysCallback,
        scope: scope
      })).toBe(expectedReturnValue);
      expect(deferred.always).toHaveBeenCalledWith({
        fn: alwaysCallback,
        scope: scope
      });
    });
  });
  return describe('cancel()', function() {
    return it('should call through to the underlying Deferred\'s cancel() method with the same specified parameters and return the same result', function() {
      var deferred, expectedReturnValue, promise;
      deferred = Ext.create('Deft.promise.Deferred');
      promise = deferred.getPromise();
      expectedReturnValue = {};
      spyOn(deferred, 'cancel').andReturn(expectedReturnValue);
      expect(promise.cancel('reason')).toBe(expectedReturnValue);
      expect(deferred.cancel).toHaveBeenCalledWith('reason');
    });
  });
});
